//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#pragma warning disable 0162

// uncomment for state machine action tracing
// #define TRACE_FSM

namespace NSemVersion
{
	using System;
	using System.Text;
	using System.Collections.Generic;

	public sealed partial class SemVersionParser
	{    
		%%{

		machine semver;
				
		action add_digit { 
			val = val * 10 + (int)Char.GetNumericValue(fc);			
			#if (TRACE_FSM)
				System.Diagnostics.Trace.WriteLine(String.Format("add_digit {0} (val={1})", fc, val));
			#endif
		} 

		action clearval { 
			val = 0;
			#if (TRACE_FSM)
				System.Diagnostics.Trace.WriteLine("clearval");
			#endif
		} 

		action buf {			
			sb.Append(fc);
			#if (TRACE_FSM)
				System.Diagnostics.Trace.WriteLine(String.Format("buf {0} (buf={1})", fc, sb.ToString()));
			#endif
		}

		action test_buf { sb.Length > 0 }

		action clearbuf {		
			sb.Clear();
			#if (TRACE_FSM)
				System.Diagnostics.Trace.WriteLine("clearbuf");
			#endif
		}

		# major version parsed
		action on_major { 
			major = val;
			#if (TRACE_FSM)
				System.Diagnostics.Trace.WriteLine(String.Format("on_major {0}", major));
			#endif
		}

		# minor version parsed
		action on_minor { 
			minor = val;
			#if (TRACE_FSM)
				System.Diagnostics.Trace.WriteLine(String.Format("on_minor {0}", minor));
			#endif
		}

		# patch version part parsed
		action on_patch { 
			patch = val;
			#if (TRACE_FSM)
				System.Diagnostics.Trace.WriteLine(String.Format("on_patch {0}", patch));
			#endif
		}

		# clear alpha mark
		action clearmarkalpha {			
			hasAlpha = false;
			#if (TRACE_FSM)
				System.Diagnostics.Trace.WriteLine("clearmarkalpha");
			#endif
		}

		# mark current fragment as containing alpha chars
		action markalpha {			
			hasAlpha = true;
			#if (TRACE_FSM)
				System.Diagnostics.Trace.WriteLine("markalpha");
			#endif
		}

		# pre release framgment parsed
		action on_prerelease_fragment {
			if (hasAlpha)
				preRelease.Add(new PreReleasePartFragment(sb.ToString()));
			else
				preRelease.Add(new PreReleasePartFragment(val));

			#if (TRACE_FSM)
				System.Diagnostics.Trace.WriteLine(String.Format("on_prerelease_fragment text={0}, val={1}, isNumeric={2}", sb.ToString(), val, !hasAlpha));
			#endif
		}	

		# pre release part parsing started
		action start_prerelease {			
			preRelease = new List<PreReleasePartFragment>();
			#if (TRACE_FSM)
				System.Diagnostics.Trace.WriteLine("start_prerelease");
			#endif
		}	

		# pre release part parsed
		action on_prerelease {
			#if (TRACE_FSM)
				System.Diagnostics.Trace.WriteLine(String.Format("on_prerelease preRelease:{0}", preRelease.ToString()));
			#endif
		}		

		action on_buildinfo_fragment {			
			buildInfo.Add(sb.ToString());
			#if (TRACE_FSM)
				System.Diagnostics.Trace.WriteLine(String.Format("on_buildinfo_fragment text={0}", sb.ToString()));
			#endif
		}

		action start_buildinfo {
			buildInfo = new List<string>();
			#if (TRACE_FSM)
				System.Diagnostics.Trace.WriteLine("start_buildinfo");
			#endif					
		}

		action on_buildinfo {
			#if (TRACE_FSM)
				System.Diagnostics.Trace.WriteLine("on_buildinfo");
			#endif
		}

		action error_major {
			throw CreateParsingException(input, fpc, fpc == eof, "major version");
		}

		action error_minor {
			throw CreateParsingException(input, fpc, fpc == eof, "minor version");
		}

		action error_patch {
			throw CreateParsingException(input, fpc, fpc == eof, "patch version part");
		}

		action error_prerelease {
			throw CreateParsingException(input, fpc, fpc == eof, "preRelease");
		}

		action error_buildinfo {
			throw CreateParsingException(input, fpc, fpc == eof, "buildInfo");
		}

		action error_general {
			throw CreateParsingException(input, fpc, fpc == eof);
		}

		version = '0' | ([1-9] digit*) $add_digit;

		prel_alnumfragment = ( [1-9] | '0' when test_buf | alpha @markalpha | '-' @markalpha )+ $buf;
		prel_fragment = ( version | prel_alnumfragment ) %on_prerelease_fragment;
		prel = prel_fragment ('.' >clearbuf >clearval >clearmarkalpha prel_fragment)*;
		
		binfo_fragment = (alnum | '-')+ $buf %on_buildinfo_fragment;
		binfo = binfo_fragment ('.' >clearbuf binfo_fragment)*;

		main := version %on_major $lerr(error_major) '.' >clearval
				version %on_minor $lerr(error_minor) '.' >clearval
				version %on_patch $lerr(error_patch)
				('-' prel >start_prerelease >clearbuf %on_prerelease)? $lerr(error_prerelease)
				('+' binfo >start_buildinfo >clearbuf %on_buildinfo)? $lerr(error_buildinfo)
				$err(error_general);

		prerelease := prel >start_prerelease %on_prerelease $lerr(error_prerelease) $err(error_general);

		buildinfo := binfo >start_buildinfo %on_buildinfo $lerr(error_buildinfo) $err(error_general);
		
		}%%
		
		%% write data;

		#if (!TRACE_FSM)
			[System.Diagnostics.DebuggerStepThrough]
		#endif
		private ParsedFragments RagelParseCore(int cs, string input)
		{
			// ragel support
			char[] data = input.ToCharArray();
			int p = 0;
			int pe = data.Length;
			int eof = data.Length;
			
			// helper parsing buffers, ...
			int val=0;
			bool hasAlpha = false;
			var sb = new StringBuilder();

			// parsing context
			int major = 0, minor = 0, patch = 0;
			List<PreReleasePartFragment> preRelease = null;
			List<string> buildInfo = null;

			%% write init nocs;
			%% write exec;

			return new ParsedFragments
			{
				Major = major,
				Minor = minor,
				Patch = patch,
				PreRelease = preRelease,
				BuildInfo = buildInfo
			};
		}
	}
}